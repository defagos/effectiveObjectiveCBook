\chapter{Resource management}
This chapter is mostly devoted to memory management in a reference-counted environment, but also discusses management of scarce resources (file descriptors, buffers, handles to kernel objects, etc.).

Since Objective-C 2.0, the language runtime supports both manual memory management through reference-counting as well as automatic management using the garbage collector.

As for any environment requiring the programmer to manage memory manually, good practices are of great help to avoid leaking memory unnecessarily, and to help the programmer write better code. The main focus of this chapter is therefore on reference-counting. A later chapter is devoted to the best practices in a garbage-collected environment.

Without good practices, reference-counting in Objective-C can lead to the same problems arising when C programmers use the malloc and free functions, or when C++ progammers use operators new and delete. But thanks to features of Objective-C and conventions applied consistently among the Objective-C programming community, most of these issues can be circumvented.

\section{Understand how reference-counting works in Objective-C}
In C++, programmers are used to smart pointers. Smart pointers are simply objects acquiring ownership of a resource, usually a piece of memory allocated from the heap, and responsible of releasing this resource when the program is done with it. The name \sl{smart pointer} stems from the fact that, thanks to C++ support for operator overloading, such objects can be given pointer-like semantics. The next iteration of the C++ standard will offer the following smart pointers:
\begin{itemize}
\item Auto pointers, which transfer ownership upon copy. Due to this often misleading semantics, the use of these smart pointers is generally not recommended.
\item Scoped pointers, which cannot transfer ownership (this is achieved by prohibiting copy operations). These smart pointers are in general intended for local use.
\item Reference-counted pointers, which count how many times the pointer is referenced by the running program. When the counter variable drops to zero, the managed resource is released. Such pointers are considered to be strong references, and suffer from retain cycle issues: If two objects each maintain a strong reference to each other, they will ultimately collapse into an unreachable object pair, leading to a memory leak. The same problem can of course also arise if a chain of object connected by reference-counted pointers closes itself.
\item Weak pointers have been introduced to solve the retain cycle problem. Those are reference-counted pointers (i.e. participating in the reference count), but with the property that objects only referenced through weak pointers can be destroyed. By identifying the head and the tail of a chain of objects connected through strong references, one can therefore break the cycle by having the tail only store a weak reference to the head. In object pairs, this ultimately translates into identifying a parent object which will store the strong reference.
\end{itemize}

Unlike the C / C++ runtimes, the non-GC Objective-C runtime applies a reference-counted strategy for memory allocated from the heap. In C++ the reference counter is transparently increased when copying or destroying reference-counted pointers, thanks to the use of C++ destructors and operator overloading. Objective-C does not have any of these features and therefore requires the programmer to explicitly ask the runtime to increment or decrement the reference counter. When the counter drops to zero, the dealloc message is sent to the object, and the memory is reclaimed. The Objective-C runtime therefore only frees the programmer from defining a private member for the reference counter and from calling dealloc when the object is no longer in use. For this reason, you must never call dealloc directly when you want to free an object. The only exception to this rule is in class hierarchies, where the dealloc method of a class must call the dealloc method of its parent class.

In Objective-C, the following messages manipulate the reference-count of an object
\begin{itemize}
\item alloc: When creating a new object from scratch, its reference count is automatically set to 1
\item Messages whose name begins with new, copy or mutableCopy: When obtaining an object from such a function, assume that its reference count has been set to 1
\item retain: This function is called when you need an additional strong reference to an object, effectively adding 1 to the internal counter
\item release: This function is called when you want a strong reference to be immediately released, effectively removing 1 from the internal counter
\item autorelease: In C++, it is safe (and considered good practice) to return a reference-counted pointer to a resource from a function which has acquired it. No such idiom can exist in Objective-C without support from the runtime. The solution is the autorelease message. By sending an autorelease message, you ask the runtime not to call dealloc when the reference counter drops to zero, but to put the object within an object pool for some more time, without having the object sent the dealloc message. During the time the autoreleased object remains in the pool, somebody might reclaim it again, bringing the object to life again. The exact time at which the object will be released is handled by the concept of autorelease pools, basically a cemetery for autoreleased objects waiting for dealloc. Many pools can coexist for a given thread, in which case they will be arranged as a stack. Autoreleased items are always put into the top pool when their counter drops to zero. At least a pool must be created per thread (otherwise autorelease cannot be called from it), additional pools can be used to get a fine-grained control over the lifetime of autoreleased objects. Note that pools might also be silently created by frameworks you use. For example, the iOS UIKit framework creates an autorelease pool when a run loop begins, and clears it when the run loop ends. In general, you should therefore assume that an autoreleased object only resides in a pool for a small amount of time. From a programmer's point of view, this in general means you can safely use an autoreleased object within the current block or the parent calling function. This covers most of the uses of autorelease you will encouter on a daily basis.
\item copy
\end{itemize}

\subsection{Things to remember}
\begin{itemize}
\item The Objective-C runtime offers a reference-counted mechanism for objects allocated on the heap.
\item The reference counter is set to 1 when sending alloc..., new..., copy... or mutableCopy... messages.
\item The reference counter is increased when retain is sent.
\item The release and autorelease messages decrease the reference counter. An object which was only sent release messages will be sent dealloc immediately. An object which received at least an autorelease message will be sent dealloc a little bit later.
\item Never call dealloc directly, except for calling the parent class dealloc function when implementing a dealloc method
\end{itemize}

\section{Use strong and weak references correctly}


10b. Weak pointers = raw pointers

11. In setters for object members, use the “retain, then release” idiom (retain the new value, then release the old one). Other idioms exist, but this is the safest and shortest (# lines of code) idiom, and the performance hit is paid only when assigning the same value (which is in general quite rare)

12. Assume that you own objects you get using new, alloc, copy or mutableCopy. You also own objects you explicitly retain. In all other cases assume you do not own them and that those objects are autorelease-d (i.e. will be released when the memory pool itself is released, which happens at least at the end of each event loop for GUI apps, i.e. after each event has been processed!). When writing your own classes, implement this rule consistently

23. When returning objects from functions which allocated them, autorelease the object upon returning it.

29. Within a given block of code / class, the number of alloc / copy / mutableCopy / retain / new must match the number of release / autorelease messages

31. autorelease needs an autorelease memory pool. Be sure you define one just after entering your program (if using XCode templates this code is readily available from the start). Additionnal autorelease pools can be defined for fine-grained control over the lifetime of autorelease objects (and are in fact defined by the framework). Autorelease pools are stacked so that newly autorelease-d objects end up in the pool at the top. Keep in mind that GUI apps release an autorelease pool at the end of each event loop. One autorelease pool stack exists for each thread, and creating / releasing this pool should be the first / last thing your thread function performs.

32. Beware of cyclic references between classes. When such cycles must be broken, identify which class must own a strong reference to the other one. In the owned class simply reference the owner class instance using a “mw_” member variable. In Cocoa, references to table data sources, outline views, notification observers and delegates are always weak. Try to stick to these conventions when writing your own classes.

33. Scarced resources (file descriptors, network connections, buffers, caches, etc.) must not be released in dealloc, since dealloc could be sidestepped (e.g. bug in reference-counting management, making the release not occur where expected; or application tear-down). Instead, create a cleanup function and call it when you want to dispose of a scarce resource in a predictable way. This call occurs usually just prior to a release call, but this way the scarce resource is guaranteed to be released, even if the release which follows does not end up in a dealloc.

34. When receiving an autoreleased object (which is what you assume in most cases, see 15), you have the choice to retain it if you think it will not survive long enough before being really released. Otherwise you can just work with it as a temporary, it will survive until the autorelease pool is released. For “local” functions it is safe to assume that such objects will survive, unless of course you nest an autorelease memory pool release in between.

46. Best practice for objects with copy semantics, when returning them from objects: return [[obj copy] autorelease];

58. Release early if you can. For example, these two code samples have the same effect:

someView = [[UIView alloc] initWithFrame: ...];
[parentView addSubview:someView];
[someView release];

and

someView = [[[UIView alloc] initWithFrame: ...] autorelease];
[parentView addSubview:someView];

but in the latter case the memory won’t be released until the autorelease pool is cleared. Of course, if all you have is a convenience constructor, the autoreleased object is fine (especially if the objects are small):

object.someStringPropertyWithCopyAttribute = [NSString stringWithFormat: ...];

//*************** Following design is incorrect, but idea - problem is correctly formulated **********

63. Suppose you have a readonly property which reflects some inner status of
an object, e.g. an NSString. Imagine e.g. an object which has some function
renewMessage which, when called, builds a random fortune message
(fortune-teller). You can access the current message using a readonly
property fortuneMessage:

@interface Fortune {
   NSString *m_fortuneMessage;
}
- (void)renewMessage;

@property (readonly) NSString *fortuneMessage;

@end

The last message which was built is stored in some internal member variable
NSString *m_fortuneMessage.

The property is simply synthesized as
@synthesize fortuneMessage = m_fortuneMessage;

But now: how do you write renewMessage? The old value must be discarded each
time a new one is built:

- (void)renewMessage
{
   [m_fortuneMessage release];
   // generateFortuneMessage conforms to Objective-C conventions
   // and returns an autoreleased NSString *
   m_fortuneMessage = [[self generateFortuneMessage] retain];
}

The first time the function is called, fortuneMessage is nil, the release is
a no-op. When later called, the release will take care of releasing the
previous value.

Note that the final release is done in dealloc:

- (void)dealloc
{
   [m_fortuneMessage release];
   [super dealloc];
}

Now imagine a similar class where there are many different ways of setting
fortuneMessage. How can you avoid littering your code with [m_fortuneMessage
release] calls (and minimize bugs due to forgetting one such call)? And how
bad does it get when we want this class to be thread-safe?

Answer: Simply add a fortuneMessageRw (read-write) property to the private
interface of the Fortune class (use categories), with retain attribute (you
might also add the nonatomic attribute if you do not need thread-safety).
This way we do not expose the setter in the public interface:

@interface Fortune (hiddenInterface)
@property (retain) NSString *fortuneMessageRw;
@end

simply synthesized as

@synthesize fortuneMessageRw = m_fortuneMessage;

Now renewMessage can be simply implemented as follows:

- (void)renewMessage
{
   self.fortuneMessageRw = [self generateFortuneMessage];
}

63 (complem.): Usually, not retain for NSString, but copy.

64. Fix for hidden interfaces: Use extensions, not categories (extension =
category without name, e.g. @interface MyClass () @end)

This is because @synthesize does not work with categories, but work with
extensions. It is also nice because the extension methods must be defined in
the same @implementation block as the main class, whereas this is not the
case for categories (whose methods must be implemented in @implementation
MyClass (categoryName) @end )

63 (complem.): Does not work: Two properties cannot be bound to the same
member variable

-> only solution: create private method for setting with copy / release
semantics :-(

63 (complem.) Mmmmh. Maybe possible to declare external interface as
readonly, but to provide a private setter function. Also beware of semantics
(retain then release; check that not receiving the same object when copying;
etc.)

//*************** Works, but not the best method. Worth mentioning it **********
//*************** to pinpoint the fact that there is no need to do that, *******
//*************** properties have a nice feature which solve the ***************
//*************** problem nicely, see below

63. (A better approach, but not optimal (optimal approach follows)) The idea
is to have the getter public and the setter private. We create the setter
manually in the private interface. This way, the setter can be used to
implement the proper setter behavior (here release, then copy). Note that in
the implementation file where the private interface is defined, we can now
use property access (dot operator) to also set the property, thanks to the
naming conventions of Objective-C. But the problem is that the setter must
match other semantics of the public getter (here nonatomic), and this has to
be implemented manually

main.m
-------

#import <Foundation/Foundation.h>

#import "Calendar.h"

int main(int argc, char *argv[])
{
 Calendar *cal = [[Calendar alloc] init];
 NSLog(@"Day 1: %@", cal.day);
 [cal nextDay];
 NSLog(@"Day 2: %@", cal.day);
}

Calendar.h
----------
#import <Foundation/Foundation.h>

@interface Calendar : NSObject {
@private
 NSString *m_day;
}

- (void)nextDay;

@property (nonatomic, readonly) NSString *day;

@end

Calendar.m
----------
#import "Calendar.h"

NSString * c_days[] = {@"Monday", @"Tuesday", @"Wednesday", @"Thursday",
@"Friday", @"Saturday", @"Sunday"};

@interface Calendar ()

- (void)setDay:(NSString *)day;

@end

@implementation Calendar

+ (void)initialize
{
 srand(time(NULL));
}

- (id)init
{
 if (self = [super init]) {
   [self nextDay];
 }
 return self;
}

- (void)nextDay
{
 // Can use usual message passing form
 //[self setDay:c_days[rand() % 7]];

 // or even property call: now the property is writable!
 self.day = c_days[rand() % 7];
}

@synthesize day = m_day;

// Not optimal: We have to match the external property attributes
// manually. Here nonatomic, therefore no @synchronized
- (void)setDay:(NSString *)day
{
 // In general we should test if day is m_day before releasing, otherwise
 // the copy will fail. But here this is not necessary since this can
 // never happen
 [m_day release];
 m_day = [day copy];
}

@end

//*************** end ***************

When examined in isolation, the reference-counting mechanism of Objective-C is no more convenient than the usual malloc / free pair of C. But combined 

63. (THE solution) See "Property re-declaration" in
http://developer.apple.com/mac/library/documentation/cocoa/conceptual/Object
iveC/Articles/ocProperties.html: declare readonly in public interface (with
copy attribute, but the copy is just here so that any redeclaration of the
property matches this attribute, and this is one we will need in the private
redeclaration for the setter). Then redeclare readwrite in private interface
(extension) with same attributes:


main.m
------
#import <Foundation/Foundation.h>

#import "Calendar.h"

int main(int argc, char *argv[])
{
 Calendar *cal = [[Calendar alloc] init];
 NSLog(@"Day 1: %@", cal.day);
 [cal nextDay];
 NSLog(@"Day 2: %@", cal.day);
}


Calendar.h
----------

#import <Foundation/Foundation.h>

@interface Calendar : NSObject {
@private
 NSString *m_day;
}

- (void)nextDay;

// here readonly (readonly & readwrite are the only attributes allowed to
// mismatch between property declaration and re-declarations). The copy
// attribute is irrelevant for the public interface but is required so
// that re-declarations match
@property (nonatomic, readonly, copy) NSString *day;

@end


Calendar.m
----------
#import "Calendar.h"

NSString * c_days[] = {@"Monday", @"Tuesday", @"Wednesday", @"Thursday",
                      @"Friday", @"Saturday", @"Sunday"};

@interface Calendar ()

- (void)setDay:(NSString *)day;

// here readwrite with copy semantics
@property (nonatomic, readwrite, copy) NSString *day;

@end

@implementation Calendar

+ (void)initialize
{
 srand(time(NULL));
}

- (id)init
{
 if (self = [super init]) {
   [self nextDay];
 }
 return self;
}

- (void)nextDay
{
 self.day = c_days[rand() % 7];
}

// generate both the public getter and the private setter with copy
// semantics
@synthesize day = m_day;

@end

63. (Remark) Of course, even if no public getter is defined, having a
private setter can eliminate the need for manual retain / release management
littering code.
(Remark2): The readwrite attribute is the default one, you do not need to
use it in the private property re-definition. Just omit the readonly.

 65 (not perfect, 65b is far better). Good practice for 63: In C++, const
variables are assigned in an initializer list once for all. There is no
support for such a concept in Objective-C, but still some variables are set
once at the object creation. For such variables, having a private property
is in general useless. For any other internal member which might change
during the object lifetime, consider providing a private setter (at least; a
public readonly accessor might still be useful). This way you can forget
about memory management for such objects, and when you are done with them or
want to reset them, you just have to assign them nil. In dealloc, instead of
calling release on objects having a property, simply assign nil.

A good idea: Introduce a notation convention for such "final" members, e.g.
mf_variableName.
The term "final" is best suited, because such members are not necessarily
const. Understand final here as "set once during object creation, and then
never replaced (but maybe changed)". Imagine e.g. a mutable array whose
purpose is to contain the results within a datasource object. The datasource
object can be sent different requests, and before each request the array
must be flushed to contain the new results. Such an array is final.
On the contrary, if the datasource were to store its results in an immutable
array, the corresponding member would not be final since it must be replaced
each time a new request is performed.

Remark: Private properties are meaningful for final objects. final instance
variables of primitive type do not suffer from memory management issues and
do not benefit (in general) from having such a private property, except when
its purpose is to encapsulate some other piece of work when setting /
getting a value. In all other cases, do not define a private property.

Remark 2: Prefixes in notation for class members always begin with m, then
add the other modifiers. The reason is that this allows to find all members
use auto-completion by entering only m and pressing ESC. In general, when
designing prefixes, find which ones design subsets and which ones supersets,
and order the prefixes accordingly.

The problem: Writing the dealloc is tedious since some objects have a
property (private setter or public) and other not. This is difficult to
maintain. Knowing that the objects are final do not convey much information
in Objective-C and could be a pain in the ass if some time later the final
character is dropped.

65b. (Excellent) No initializing concept in Objective-C and no support,
therefore do NOT introduce one artificially. Just apply the following rule:
All member objects must have a corresponding setter (at least private). In
the implementation of a class, *always* use those setters (except in the
setter / getter implementation of course!), *never* access member variables
directly. In the destructor, set all objects to nil.
This way, encapsulation is preserved, the correct behavior is applied when
getting / setting values, and additional instructions can be bundled with
those operations consistently. Moreover, setting to nil is by construction
equivalent to calling release. This way the code is similar to the one
written with garbage collection enabled on MacOS! Moreover this is much
easier to follow than 65, and it is easier to maintain consistently. The
only issue is performance, but Objective-C is already a "slow" language.
Moreover, if performance is at premium, some classes can be written without
this convention where needed. As always, flexibility and encapsulation is
traded against performance. But this should not really be an issue 90% of
the time. Of course, this requires writing some more code (but only a little
more thanks to property synthesization), but at least this also forces the
programmer to carefully think about threading issues when accessing objects.

Remark: For primitive types, only declare private properties if you need to
bundle some code with a set / get operation. Primitive types do not suffer
from memory management issues, therefore "bare" properties would bring
nothing more. Of course you still might want to provide a public properties
for client to access an internal variable.

Remark 2: Using this approach, you will usually assign autorelease-d objects
directly:
 self.someMember = [[[Clazz alloc] init] autorelease];
Another idiom when you cannot autorelease (e.g. when creating a crazy number
of objects in a loop) is:
 self.someMember = [[Clazz alloc] init];
 [self.someMember release];

Remark 3: Private properties also motivate why it is not wise to create a
property which returns a type different from the one of the underlying
member (most probably upcasted). See 69.

66. When implementing a class, access member variables through their
properties as much as possible. This also includes the dealloc function in
which you should call self.variable = nil. The reason is the following: your
setter was maybe performing some additional work for you, it might therefore
also was implemented to perform some cleanup work when nil was assigned.
Simply releasing without the setter would have required you to duplicate
this code in the dealloc function.
Always using setters therefore increases encapsulation and provides the
correct behavior when assigning and dealloc-ing.

65b (complem.): Do not write private property for members of primitive type,
except if:
- some code must be bundled with the set, the get, or both
- a public property exists for getting the value; by defining a private
property for the set, you ensure that the variable can be accessed
consistently within the implementation file (otherwise it would be confusing
to access the variable using self.m_name; sometimes this could be dropped,
and if the getter is bundled with code as well, then encapsulation has been
breached).

65b (complem.): By using properties this way, we in fact are close to
the use of smart pointers in C++. No need to manually release the
memory, assignment does it for us.



